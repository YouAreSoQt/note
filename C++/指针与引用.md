# 引用与指针

## 定义

**指针**是一个变量,存储的是一个地址,指向内存的一个存储单元;
**引用**是原变量的一个别名,跟原来的变量实质上是同一个东西.(汇编层实现就是一个常量指针----指针的指向不能改变)

## 不同点

- **指针可以有多级; 引用只能是一级**
```cpp
int **p; // ok
int &&r; // error
```
- **指针可以在定义时不初始化; 引用必须在定义的时候初始化**
```cpp
int *p; // ok
int &r; // error
```
- **指针可以指向```nullptr```; 引用不可以为```nullptr```**
```cpp
int *p = nullptr; // ok
int &r = nullptr; // error
```
- **指针初始化后可以再改变指向; 引用不行**
```cpp
int a = 0;
int *p = &a;
int &r = a;

int b = 1;
p = &b; // ok
r = b;  // error
```
- **sizeof的运算结果不同**
```cpp
// 64位机器上
int a = 0;
int *p = &a;
int& r = a;

std::cout << sizeof(p) << std::endl; // "8". int*指针的大小
std::cout << sizeof(r) << std::endl; // "4". int类型的大小
```
- **自增运算意义不同**
```cpp
int a = 0;
int *p = &a;
int &r = a;

p++; // p指向a后面的内存地址
r++; // 相当于a++
```
- **使用指针需要判空; 但引用不需要**

## 引入引用的缘由

**运算符重载**.由于地址类型(指针)本身已经有了很多运算定义(如+/-/[]之类的),所以为了不引起歧义,运算符重载只能作用于类的实例上,那么就势必要在值语义中引入一个新的类似指针的概念----这就是引用.

### 引申

#### 引入运算符重载的意义

为了代码能够在形式上,使得类与内置类型能够使用同样形式的代码.(如自定义了一个Number的类型,表达两个Number相加,重载下"+",比调用调用一个"plus"函数更符合人的直觉)

# GC
## 引用计数
基本思路是给每个对象添加一个引用计算器，每当有一个地方引用它时，引用计数+1；当引用失效时，引用计数-1。当引用数为0时，代表对象已经没有地方在使用，自动删除对象。
### 优点
* 实现简单
* 失效直接释放，不用额外中断
### 缺点
* 有循环引用的问题存在

## 可达性分析
选取一系列GC Roots，从这些节点出发，不能通过引用链相连的对象，则视为可回收的对象。
### 可作为GC Roots的对象
* 虚拟机栈中引用的对象
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈引用的对象
### 垃圾收集算法
#### 标记-清除算法
先标记出所有需要回收的对象，然后再统一回收所有对象。
##### 缺点
* 效率不高
* 产生大量碎片

#### 复制算法
为了解决“标记-清除”的效率问题，此算法应时而生。
把可用内存平均划分为两块A与B，一次只用一块。如果当前在A创建对象，当A内存用完时，会把存活对象复制到B，再一次性清空A。

#### 标记-整理算法
标记完对象后，把标记对象往一堆移动。再清除边界以外部分。

#### 分代收集算法
在java中一般会划分成两代，新生代与老年代。新生代在每次GC时，大多对象会死去，仅存活少量对象，这时候采用“复制”算法。老年代对象存活率往往较高，采用“标记-清理”或“标记-整理”更加合理。

## 资料
[深入理解java虚拟机——垃圾收集器](https://item.jd.com/10026483887253.html)
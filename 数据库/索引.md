# 索引

## 概念

索引是一个单独的、物理的数据库结构，是数据库的一个表中所包含的值的列表，其中注明了表的各个值所在的存储位置。

## 作用

提高检索数据的能力

## 分类(按照储存结构划分)

* 簇索引(Clustered Index)
* 非簇索引(Nonclustered Index)

### 簇索引

**簇索引**对表的物理数据页中的数据按列进行排序，然后再重新存储到磁盘上，即簇索引与数据是混为一体的，它的叶节点中存储的是实际的数据。
> 表的数据行只能以一种排序方式存储在磁盘上，所以一个表只能有一个簇索引。

### 非簇索引

**非簇索引**具有与表的数据完全分离的结构，使用非簇索引不必将物理数据页中的数据按列排序。非簇索引的叶节点中存储了关键字的值和行定位器。
> 行定位器的结构和存储内容取决于数据的存储方式。
>
> * 如果数据是以簇索引方式存储的，则行定位器中存储的是簇索引的索引键；
> * 如果数据不是以簇索引方式存储的，则行定位器存储的是指向数据行的指针，这种方式又称为堆存储方式（Heap Structure）。非簇索引将行定位器按关键字进行排序，这个顺序与表的行在数据页中的排序是不匹配的。

由于非簇索引使用索引页存储，比簇索引需要更多的存储空间，且检索效率较低。但一个表只能建一个簇索引，当用户需要建立多个索引时，就需要使用非簇索引了。从理论上讲，一个表最多可以建**249**个非簇索引。

## 创建

**创建素引**的基本关键字为**CREATE INDEX**，在其后要指明创建索引的名称，并需要指明表的名字及创建索引的列。
语法如下:

```sql
create index index_name on table_name(column_name1, [column_name2], ...);
```

每个索引必须有惟一的名字。**ON**关键字后面为创建索引的表的名字，在括号内列出索引包含的列（当然，可以为多列）。

## 销毁

```sql
drop index index_name
```

### 注意

在SQL Server中，用DROP INDEX语句销毁索引时，我们一定要指明索引所在表的名字，如实例代码中的StudentInfo.Name_Index。

## 惟一索引

惟一索引是指不允许在两行中存在相同的索引值。惟一索引可以拥有一行或者多行。如果用户试图使用INSERT或UPDATE语句，在拥有惟一索引的数据中生成一个重复的值，那么INSERT或者UPDATE就会被终止，SQL服务器会生成一个错误信息。

### notice

当创建惟一索引时，我们应确保被索引的列不允许NULL值。**例如**，SQL Server将NULL也看作是一个值，如果创建惟一索引的列允许NULL值，假定原先该列不存在NULL值，那么向其中插入NULL值时，第一个是合法的，第二个就会失败。因为两个NULL值被视为违背惟一性原则。

**当然，创建惟一性索引的前提是，创建索引的列中已有的记录本身没有重复的值。否则，系统会报错，创建失败。**

在对表创建了一个簇集索引之后，在插入新行或是更新簇集索引一部分的列值时，DBMS将自动地重新排序。因此，对那些经常大量插入行或更新索引列值的表，我们尽量不要建立簇集索引。

## 使用注意事项

* 对小的数据表来说，使用索引并不能提高检索效率，因此不需对其创建索引。
* 当用户要检索的字段的数据包含有很多数值或很多空值（NULL）时，为该字段创建索引，会大大提高检索效率。
* 当用户查询表中的数据时，如果查询结果包含的数据（行）较少，一般少于数据总数的25%时，使用索引会显著提高查询效率。反之，如果用户的查询操作返回结果总是包含大量数据，那么索引的用处不大。
* 索引列在WHERE子句中应频繁使用。例如，我们在学生姓名字段上建了索引，但实际查询中并不是经常用姓名作为查询条件，该索引就没有发生作用。
* 我们要先装数据，后建索引。对于大多数的表，总有一批初始数据需要装入。该原则是说，建立表后，我们要先将这些初始数据装入表，然后再建索引，这样可以加快初始数据的录入。如果建表后就建索引，那么在输入初始数据时，每插入一个记录都要维护一次索引；当然，对于索引来说，早建和晚建都是允许的。
* 索引提高了数据检索的速度，但也降低了数据更新的速度。如果要对表中的数据进行大量更新，我们最好先销毁索引，等数据更新完毕再创建索引，这样会提高效率。
* 索引要占用数据库空间。在设计数据库时，我们要把需要的索引空间考虑在内。
* 我们要尽量把表和它的索引存放在不同的磁盘上，这样会提高查询速度。

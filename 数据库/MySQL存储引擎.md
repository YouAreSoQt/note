# MySQL存储引擎

## 种类

*   InnoDB
*   MyISAM
*   MEMORY

## InnoDB

InnoDB 是事务型数据库的首选引擎，支持事务安全表 (ACID)，支持行锁定和外键。MySQL5.5.5 之后，InnoDB 作为默认存储引擎

### InnoDB 主要特性：

* InnoDB 给 MySQL 提供了具有提交、回滚和崩溃恢复能力的事务安全(ACID 兼容)存储引擎。InnoDB 锁定在行级并且也在 SELECT 语句中提供一个类似 Oracle 的非锁定读。这些功能增加了多用户部署和性能。在 SQL 查询中，可以自由地将 InnoDB 类型的表与其他 MySQL 的表的类型混合起来，甚至在同一个查询中也可以混合。
* InnoDB 是为处理巨大数据量的最大性能设计。它的 CPU 的效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的。
* InnoDB 存储引擎完全与 MySQL 服务器整合，InnoDB 存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB 将它的表和索引存在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘分区）。这与 MyISAM 表不同，比如在 MyISAM 表中每个表被存在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被艰制为 2GB 的操作系统上。
* InnoDB 支持外键完整性约束（FOREIGN KEY)。 存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB 会被每一行生成一个 6B 的 ROWID，并以此作为主健。外键约束其实降低了表的查询速度，但是增加了表之间的耦合度。
* InnoDB 被用在众多需要高性能的大型数据库站点上。 InnoDB 不创建目录，使用 InnoDB 时，MySQL 将在 MYSQL 数据目录下创建一个名为 ibdata1 的 10MB 大小的自动扩展数据文件，以及两个名为ib\_logfile() 和 ib\_logfile1 的 5MB 大小的日志文件。
* 可以通过自动增长列，方法是auto_increment。
* 支持事务。默认的事务隔离级别为可重复度，通过MVCC（并发版本控制）来实现的。
* 使用的锁粒度为行级锁，可以支持更高的并发
* 配合一些热备工具可以支持在线热备份
* 在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度
* 对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上

当然InnoDB的存储表和索引也有下面两种形式：
* 使用共享表空间存储：所有的表和索引存放在同一个表空间中。
* 使用多表空间存储：表结构放在frm文件，数据和索引放在IBD文件中。分区表的话，每个分区对应单独的IBD文件，分区表的定义可以查看我的其他文章。使用分区表的好处在于提升查询效率。

> 对于InnoDB来说，最大的特点在于**支持事务**。但是这是以**损失效率**来换取的。

## MyISAM

MyISAM 基于 ISAM 的存储引擎，并对其进行扩展。它是在 Web、数据存储和其他应用环境下最常用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务。在 MySQL5.5.5 之前的版本中，MyISAM 是默认存储引擎。

### MyISAM 主要特性：

*   大文件（达 63 位文件长度）在支持大文件 系统和操作系统上被支持。
*   当把删除、更新及插入操作混合使用的时候，动态尺寸的行产生更少的碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块来自动完成。
*   每个 MyISAM 表最大索引数是 64，这也可以通过编译来改变。对于键长度超过 250B 的情况，一个超过 1024B 的键将被用上。
*   BLOB 和 TEXT 列可以被索引。
*   NULL 值被允许在索引的列中。这个值占每个键的 0\~1 个字节。
*   所有数字键值以高字节优先被存储以允许一个更高的索引压缩。
*   每表一个 AUTO\_INCREMENT 列的内部处理。MyISAM 为 INSERT 和 UPDATE 操作自动更新这一列。使得 AUTO\_INCREMENT 列更快（至少 10%）。在序列顶的值被删除除之后就不能再利用。
*   可以把数据文件和索引文件放在不同目录。
*   每个字符列可以有不同的字符集。
*   有 VARCHAR 的表可以固定或动态记录长度。
*   VARCHAR 和 CHAR 列可以多达 64KB

> 使用 MyISAM 引擎创建数据库，将生产 3 个文件。文件的名字以表的名字开始，扩展名指出文件类型：frm 文件存储表定义，数据文件的扩展名为 .MYD(MYData)，索引文件的扩展名是 .MYI（MYIndex)。
>
> *   frm文件: 储存表的定义数据
> *   MYD文件: 存放表具体记录的数据
> *   MYI文件: 存贮索引
>
> frm和MYI可以存放在不同的目录下。MYI文件用来存储索引，但仅保存记录所在页的指针，**索引的结构是B+树结构**。

### 支持数据的类型也有三种：

*   **静态固定长度表.** 这种方式的优点在于存储速度非常快，容易发生缓存，而且表发生损坏后也容易修复。缺点是占空间。这也是**默认的存储格式**。
*   **动态可变长表.** 优点是节省空间，但是一旦出错恢复起来比较麻烦。
*   **压缩表.** 上面说到支持数据压缩，说明肯定也支持这个格式。在数据文件发生错误时候，可以使用check table工具来检查，而且还可以使用repair table工具来恢复。

有一个重要的特点那就是**不支持事务**，但是这也意味着他的**存储速度更快**，如果你的读写操作允许有错误数据的话，只是追求速度，可以选择这个存储引擎。

## MEMORY

MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。每一个表实际上和一个磁盘文件关联。文件是frm。

### MEMORY 主要特性有：

*   MEMORY 表的每个表可以多达 32 个索引，每个索引 16 列，以及 500B 的最大键长度。
*   MEMORY 存储引擎引擎执行 HASH 和 BTREE 索引。
*   可以在一个 MEMORY 表中有非唯一键。
*   MEMORY 不支持 BLOB 或 TEXT 列。
*   MEMORY 表使用一个固定的记录长度格式。
*   MEMORY 支持 AUTO\_INCREMENT 列和对包含 NULL 值的列索引。
*   MEMORY 表内容被存在内存中，内存是 MEMORY 表和服务器在查询处理时的空闲中创建的内部表共享。
*   MEMORY 表在所有客户端之间共享（就像其他任何非 TEMPORARY 表）。
*   当不再需要 MEMORY 表的内容时，要释放被 MEMORY 表使用的内存，应该执行 DELETE FROM 或 TRUNCATE TABLE，或者删除整个表（使用 DROP TABLE)。
*   支持的锁粒度为表级锁。所以，在访问量比较大时，表级锁会成为MEMORY存储引擎的瓶颈
*   由于数据是存放在内存中，一旦服务器出现故障，数据都会丢失
*   查询的时候，如果有用到临时表，而且临时表中有BLOB，TEXT类型的字段，那么这个临时表就会转化为MyISAM类型的表，性能会急剧降低
*   默认使用hash索引
*   如果一个内部表很大，会转化为磁盘表

[存储引擎的选择(各引擎的对比)](https://www.runoob.com/note/28228)
